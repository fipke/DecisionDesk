DecisionDesk – Especificação Mestre para Copilot (Atualizada 2026)

Este arquivo unifica todos os requisitos e decisões do projeto
DecisionDesk até fevereiro de 2026. Ele consolida os pedidos
originais, a documentação existente (DOCUMENTATION.md), a
Especificação Atualizada e as discussões mais recentes. Copilot
deve ler este arquivo antes de gerar qualquer PR. Caso algum
requisito mude, atualize este arquivo e execute um PR 00 (Spec
Fixup) para alinhar o código ao novo escopo.

1. Visão Geral

O DecisionDesk é um sistema multiplataforma para capturar, organizar e
transformar reuniões em transcrições e resumos inteligentes.
Os objetivos centrais são:

Gravar reuniões em iOS e macOS, com áudio de alta qualidade
(AAC 48 kHz mono ~96 kbps), salvando sempre o arquivo no backend para
posterior reprodução. A gravação registra hora de início/fim,
localização GPS (quando autorizado) e tags dinâmicas (ex.:
pastor:João, empresa:Leblon, tema:Dashboard).

Transcrição manual: nenhuma gravação é transcrita
automaticamente. O usuário decide quando transcrever e com qual
provedor (vide seção 4). Enquanto isso, o backend mantém o status
NEW.

Resumos configuráveis: gerar notas e minutos de reunião por meio
de templates em Markdown com variáveis. Os modelos de resumo
comerciais recomendados são GPT‑4‑mini, Claude 3 Haiku ou
Open‑mistral‑nemo, com custo por token competitivo.
Estudar a adoção futura de modelos open source para resumos locais
(BART, Pegasus, T5).

Privacidade e custo: priorizar transcrição local (
desktop_local ou server_local) para reduzir custo e expor
menos dados; oferecer remote_openai apenas como fallback.

Offline‑first: tanto o iOS quanto o macOS funcionam offline.
Filas, gravações e transcrições são persistidas localmente (SQLite) e
sincronizam com o backend assim que houver rede.

2. Camadas e Responsabilidades

Backend (Java 21 + Spring Boot 4) – É a única camada que
interage com provedores externos de IA. Provê API REST versionada
(/api/v1), grava e indexa áudios, transcrições, resumos,
modelos e custos. Calcula custos em USD e converte para BRL. Pode
processar transcrições localmente (server_local) ou via OpenAI
(remote_openai). Mantém a fila de jobs e a lista de modelos
disponíveis reportados pelo macOS.

Aplicativo iOS (React Native) – Grava áudio, salva no SQLite e
envia ao backend quando conectado (Wi‑Fi por padrão, dados móveis
opcional com aviso de MB). O usuário seleciona pasta, tipo,
participantes e tags antes/depois de gravar. A lista de reuniões
mostra status, custo e transcrições; o botão “Transcrever” envia
um pedido ao backend para transcrever com o provedor/modelo
escolhido. Pode pré‑selecionar o modelo padrão definido pela
pasta ou tipo.

Aplicativo macOS (Electron + React) – Sincroniza reuniões e
transcrições, exibe uma fila persistente de jobs (SQLite). O
Mac executa transcrições localmente com whisper.cpp. O usuário
decide quando aceitar cada job. O app reporta a cada 30 min
quais modelos estão instalados, incluindo tamanho (tiny, base,
small, medium, large) e quantização. Essa lista é enviada ao
backend, que armazena a última lista conhecida e a expõe ao iOS.

Web app – Planejada para fases futuras; fornecerá gestão e
visualização das reuniões via navegador, permitindo editar
templates e ver dashboards.

3. Organização de Conteúdo
Pastas

Estrutura hierárquica (cultos/igreja3.15, fornecedorA, etc.).
Cada pasta pode configurar:

Template de resumo: arquivo .md com placeholders.

Modelo Whisper padrão: ex.: small ou base, preferindo
transcrição local.

Tags padrão: chave–valor (ex.: pastor, empresa).

Participantes frequentes: lista de participantes predefinidos.

Tipos de reunião

Categorias como “Reunião Gerencial Leblon”, “Culto” ou “One Way
Semanal”. Cada tipo define:

Template (pode ser compartilhado por múltiplas pastas).

Modelo Whisper padrão (pode ser sobrescrito pela pasta).

Tags obrigatórias (ex.: titulo_pregacao para cultos).

Quando uma reunião é criada, as tags e o modelo são mesclados a
partir da pasta e do tipo. Conflitos seguem a prioridade (pasta > tipo
por padrão, configurável). Usuários podem editar antes da gravação.

Participantes

Entidade persistente com campos opcionais: empresa, cargo,
avatar e notas. Permite filtrar reuniões, sugerir prompts e
enriquecer resumos. Selecionar participantes é opcional ao criar
reuniões, mas influencia o template.

Tags dinâmicas e metadados

Além das tags padrão, o usuário pode adicionar tags arbitrárias na
gravação (ex.: pastor:Maria, tema:Valores). Todos os áudios
registram horário, duração, localização e dispositivo. Esses
metadados alimentam filtros e resumos futuros.

4. Provedores de Transcrição e Fluxo de Jobs

Existem três provedores:

desktop_local – Transcrição local no Mac usando whisper.cpp.
O Mac mantém uma fila persistente de jobs (SQLite). Jobs vêm do
backend via GET /queue?deviceId=…; o usuário escolhe o modelo e
aceita o job. O app baixa o áudio (caso ainda não tenha),
processa offline e envia o resultado de volta (POST /meetings/{id}/transcript). Custos são zero; UsageRecord armazena
metadados (duração, modelo, provedor).
Se o Mac estiver offline, o iOS ainda mostra modelos utilizando a
última lista reportada.

server_local – Transcrição local no servidor. Sugerido para
redução de custos quando a máquina do servidor tem capacidade. O
backend seleciona o modelo (tiny‑large) e usa whisper.cpp.

remote_openai – Chama API do Whisper. Útil para fallback ou
hardware limitado. Cobra ~USD 0,006/min; backend converte para BRL.

Fluxo: Uma vez que o usuário clica em “Transcrever”, o backend
cria um job com o provedor e modelo. Se for desktop_local, o job vai
para a fila do Mac; se for server_local ou remote_openai, o
backend processa e retorna o transcript. Após a transcrição, o
backend persiste o texto, registra custos e atualiza o status para
DONE (ou ERROR).

5. Summarização

Após transcrição, o usuário pode gerar um resumo. O processo:

Selecionar template (ou usar o padrão da pasta/tipo) e nível
(conciso, normal, detalhado). O template está em Markdown e pode
incluir seções como Objetivos, Decisões, Ações (responsável/prazo),
Riscos, Pendências e Roteiro.

Escolher provedor: inicialmente será OpenAI com modelos de
custo baixo, como GPT‑4‑mini ou Claude 3 Haiku.
O backend calcula custos via tokens. Futuros modelos locais (BART,
Pegasus, T5) serão avaliados.

O backend cria Summary, grava UsageRecord para custos e
fornece o texto em Markdown. O app apresenta e permite exportar.

6. Custos e Orçamentos

Whisper: calcular minutos a partir da duração (ou estimativa por
tamanho/bitrate). Multiplicar pela tarifa (WHISPER_PRICE_PER_MIN_USD).

GPT: somar tokens de entrada/saída e multiplicar pelos preços do
modelo escolhido (consultar recomendações de custo‑benefício).

Orçamentos mensais: cada tenant/pasta pode ter limite (ex.:
US$ 10). Alertar quando atingir 80 %; bloquear novas transcrições ou
resumos se ultrapassar 100 %. Custos locais (desktop_local e
server_local) são zero, mas registram duração para estatísticas.

7. Persistência e Sincronização

O iOS grava dados em SQLite: local_meetings, local_assets e
sync_queue. O backend é a fonte da verdade; as IDs locais são
reconciliadas após upload.

O macOS mantém queue.sqlite para jobs e models.sqlite para
versões de modelos instalados. Usa pasta de dados do usuário
(~/Library/Application Support/DecisionDesk).

Sincronização de modelos: Mac chama POST /models/report a
cada 30 min e envia models.json. Backend guarda DesktopModelReport
com timestamp. iOS chama GET /models/available para mostrar
opções. Se a lista estiver desatualizada, pode exibir aviso.

Fila persistente: Jobs são sincronizados entre backend e Mac via
endpoints /queue. Se a fila estiver em ERROR ou EXPIRED, o
usuário pode deletar/recriar.

8. Diretivas para Copilot

Leia sempre este arquivo (decisiondesk_copilot_master.md) e
DOCUMENTATION.md/specs antes de iniciar qualquer atividade. Se
houver divergência com o código já existente, abra um PR 00 –
Spec Fixup para alinhar.

Planeje PRs pequenos: por exemplo, PR 03 para implementar o
iOS v1 (gravação, upload, transcrição manual), PR 04 para o macOS v1
(fila UI, sincronização de modelos), PR 05 para orçamento mensal, e
assim por diante. Cada PR deve incluir testes, docstrings e
updates no CHANGELOG.

Não transcreva automaticamente: sempre requer ação do usuário.

Armazene todos os áudios no backend: o macOS pode transcrever
localmente, mas o áudio deve existir no servidor para backup.

Suporte a modelos padrão por pasta e tipo: preencha
automaticamente no formulário, mas permita override. Tags devem
mesclar contexto de pasta e tipo.

Documente e localize: use PT‑BR na interface, dark mode por
padrão, e garanta acessibilidade. Diarização e exportações devem
entrar em PRs posteriores.

Observação: Inspiramo‑nos em apps como Granola (privacidade,
template customizável, notas enriquecidas) e MacWhisper
(múltiplos modelos, exportação em vários formatos). As
referências servem para guiar decisões de usabilidade e recursos.
Modelos de resumo open source são considerados para reduzir custos e
latência.